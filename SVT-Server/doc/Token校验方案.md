# Token校验与活跃度管理方案

## 一、整体架构

```
客户端 Token(10小时有效期)
   ↓
Token校验层
   ↓
Caffeine本地缓存(5分钟) ←→ Redis分布式缓存(10小时) 
   ↓
黑名单管理
```

## 二、缓存架构

### 1. 本地缓存(Caffeine)
```
┌────────────────────┐
│ 容量: 80个用户     │
│ 策略: LRU淘汰     │
│ 时间: 5分钟       │
└────────────────────┘

配置参数:
- initialCapacity: 100
- maximumSize: 1000
- expireAfterWrite: 5分钟
- recordStats: true
- removalListener: 记录淘汰原因
```

### 2. 分布式缓存(Redis)
```
┌────────────────────┐
│ 所有用户缓存       │
│ 时间: 10小时       │
│ 黑名单Token       │
└────────────────────┘

配置参数:
- 过期时间: 10小时
- 序列化方式: JSON
- 压缩: 开启
```

## 三、数据结构

### 1. 用户缓存信息
```
UserCacheInfo {
    userId         // 用户ID
    token          // 当前Token
    username       // 用户名
    lastActiveTime // 最后活跃时间
    accessCount    // 访问计数
    orgId          // 组织ID
    roles          // 角色列表
    permissions    // 权限列表
}
```

### 2. 缓存配置
```
Caffeine配置:
- maximumSize(80)  // 固定容量80
- expireAfterWrite(5, MINUTES)
- removalListener  // 监听淘汰事件
- recordStats      // 开启统计
- initialCapacity  // 初始容量100

Redis配置:
Key: "user:{userId}" 
过期时间: 5分钟
序列化: JSON
压缩: 开启

黑名单配置:
Key: "token:blacklist"
Value: Set<String> // 失效Token集合
过期时间: 10小时
```

## 四、核心流程

### 1. 用户登录流程
```
1. 用户登录成功
2. 生成Token(10小时有效期)
3. 创建UserCacheInfo对象
4. 同时写入Caffeine和Redis缓存(5分钟过期)
5. 返回Token给客户端
```

### 2. Token校验流程
```
请求进入 →→→ 检查Token是否在黑名单
     ↓
检查Token基础有效性(签名/过期)
     ↓
查询Caffeine本地缓存
     ↓
命中 → 更新访问信息
     ↓
未命中 → 查询Redis
     ↓
Redis有数据 → 同步到Caffeine(自动淘汰)
     ↓
Redis无数据 → Token失效,加入黑名单
```

### 3. 缓存淘汰机制
```
情况1: 容量满80时新增缓存
- LRU自动淘汰最久未使用
- 新数据直接添加
- 记录淘汰原因

情况2: 过期时间到达
- 自动清除过期数据
- 需要时从Redis恢复
- 记录过期原因

情况3: 主动清除
- 用户注销
- Token加入黑名单
- 记录清除原因
```

### 4. 数据同步策略
```
Caffeine → Redis:
- 更新活跃时间
- 更新访问计数
- 异步更新
- 失败重试

Redis → Caffeine:
- 按需加载
- 淘汰后重新访问
- 自动覆盖不活跃数据
- 批量加载优化
```

## 五、失效处理

### 1. Token失效场景
```
1. Token超过10小时
2. 用户超过5分钟未活跃
3. Token被加入黑名单
4. 缓存被淘汰
```

### 2. 黑名单管理
```
1. 黑名单存储在Redis中
2. 黑名单中的Token有效期与原Token一致
3. Token校验时优先检查黑名单
4. 定期清理过期黑名单
```

## 六、性能优化

### 1. 内存优化
```
本地内存占用固定
- 最多80个用户数据
- 自动淘汰机制
- 可预测的内存使用
- 压缩数据存储
```

### 2. 访问优化
```
热点数据本地访问
- 活跃用户快速响应
- 减少Redis访问
- 自动调整热点数据
- 批量加载优化
```

### 3. 可用性提升
```
双层缓存容灾
- Redis异常时本地可用
- 数据自动同步
- 平滑的性能下降
- 降级策略
```

## 七、监控指标

### 1. 缓存指标
```
- 本地缓存命中率
- 淘汰频率统计
- 活跃用户数量
- Redis同步频率
- 内存使用情况
- 访问延迟统计
```

### 2. 性能指标
```
- Token验证耗时
- 缓存访问耗时
- 同步操作耗时
- 内存占用趋势
- 淘汰原因分析
```

## 八、使用建议

### 1. 容量设置
```
- 根据并发用户数调整
- 监控淘汰频率
- 适当预留余量
- 定期评估容量
```

### 2. 同步策略
```
- 及时同步活跃状态
- 避免频繁Redis访问
- 合理设置过期时间
- 异步更新优化
```

### 3. 异常处理
```
- Redis连接异常降级
- 容量限制异常处理
- 数据一致性保证
- 监控告警机制
```

## 九、方案优势

### 1. 资源可控
- 固定的内存占用
- 可预测的性能
- 合理的资源利用
- 自动资源回收

### 2. 高效访问
- 热点数据本地化
- 自动调整缓存内容
- 最小化网络请求
- 批量处理优化

### 3. 简单可靠
- 实现逻辑简单
- 容易监控和维护
- 故障时可降级
- 配置灵活

### 4. 弹性伸缩
- 容量可配置
- 策略可调整
- 便于横向扩展
- 动态调整能力
